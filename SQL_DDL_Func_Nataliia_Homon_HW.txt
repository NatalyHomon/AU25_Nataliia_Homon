1.What operations do the following functions perform: film_in_stock, film_not_in_stock, inventory_in_stock, get_customer_balance, inventory_held_by_customer, rewards_report, last_day? You can find these functions in dvd_rental database.

film_in_stock => Returns a list of inventory_id values that are currently in stock (available for rental).

film_not_in_stock => Returns inventory_id values that are not in stock (currently rented out).

inventory_in_stock => Returns TRUE/FALSE depending on whether a specific inventory item is currently available.

get_customer_balance => Calculates a customer’s balance based on payments and rentals.

inventory_held_by_customer => Returns all films currently held by the customer (rentals that have not been returned).

rewards_report => Should return customers who qualify for the rewards program.

last_day=> Returns the last day of the month for the given date.

2.Why does ‘rewards_report’ function return 0 rows? Correct and recreate the function, so that it's able to return rows properly.

ISHUES:
interval should be 1 month vs 3 month according business logic, changed here - 
last_month_start := current_date - '1 month'::interval;
2. wrong syntax I having, we group by customer_id, should count(*) or count(payment_id)
3.I changed current_date with the date which exists in the database dvdrental, as the last payment date was in 2017, so we can't check with current date whether function works

CREATE OR REPLACE FUNCTION public.rewards_report(min_monthly_purchases integer, min_dollar_amount_purchased numeric, p_ref_date date DEFAULT current_date)
 RETURNS SETOF customer
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    last_month_start DATE;
    last_month_end DATE;
rr RECORD;
tmpSQL TEXT;
BEGIN

    /* Some sanity checks... */
    IF min_monthly_purchases = 0 THEN
        RAISE EXCEPTION 'Minimum monthly purchases parameter must be > 0';
    END IF;
    IF min_dollar_amount_purchased = 0.00 THEN
        RAISE EXCEPTION 'Minimum monthly dollar amount purchased parameter must be > $0.00';
    END IF;

    last_month_start := date_trunc('month', (p_ref_date - interval '1 month'))::date;

   last_month_end := (last_month_start + interval '1 month - 1 day')::date;

    /*
    Create a temporary storage area for Customer IDs.
    */
    CREATE TEMPORARY TABLE tmpCustomer (customer_id INTEGER NOT NULL PRIMARY KEY);

    /*
    Find all customers meeting the monthly purchase requirements
    */

    tmpSQL := 'INSERT INTO tmpCustomer (customer_id)
        SELECT p.customer_id
        FROM payment AS p
        WHERE DATE(p.payment_date) BETWEEN '||quote_literal(last_month_start) ||' AND '|| quote_literal(last_month_end) || '
        GROUP BY customer_id
        HAVING SUM(p.amount) > '|| min_dollar_amount_purchased || '
        AND COUNT(*) > ' ||min_monthly_purchases ;

    EXECUTE tmpSQL;

    /*
    Output ALL customer information of matching rewardees.
    Customize output as needed.
    */
    FOR rr IN EXECUTE 'SELECT c.* FROM tmpCustomer AS t INNER JOIN customer AS c ON t.customer_id = c.customer_id' LOOP
        RETURN NEXT rr;
    END LOOP;

    /* Clean up */
    tmpSQL := 'DROP TABLE tmpCustomer';
    EXECUTE tmpSQL;

RETURN;
END
$function$
;

3.Is there any function that can potentially be removed from the dvd_rental codebase? If so, which one and why?

group_concat and _group_concat functions can be removed. These custom functions emulate MySQL’s GROUP_CONCAT() feature.
However, PostgreSQL already provides a built-in equivalent:string_agg().Thus both functions are redundant and can be safely removed.

There is one more function that can potentially be removed: last_day(timestamptz).
Its logic (computing the last day of a month) can be easily expressed using built-in date and interval operations, e.g.:

(date_trunc('month', some_date) + interval '1 month - 1 day')::date


In the current dvdrental schema it is mainly used inside rewards_report.
If we refactor rewards_report to use the expression above directly (as we already did), then last_day becomes dead code and can safely be removed as well.(it was replaced in the task 2)

4.The ‘get_customer_balance’ function describes the business requirements for calculating the client balance. Unfortunately, not all of them are implemented in this function. Try to change function using the requirements from the comments.

part marked bold was changed

CREATE OR REPLACE FUNCTION public.get_customer_balance(p_customer_id integer, p_effective_date timestamp with time zone)
 RETURNS numeric
 LANGUAGE plpgsql
AS $function$
       --#OK, WE NEED TO CALCULATE THE CURRENT BALANCE GIVEN A CUSTOMER_ID AND A DATE
       --#THAT WE WANT THE BALANCE TO BE EFFECTIVE FOR. THE BALANCE IS:
       --#   1) RENTAL FEES FOR ALL PREVIOUS RENTALS
       --#   2) ONE DOLLAR FOR EVERY DAY THE PREVIOUS RENTALS ARE OVERDUE
       --#   3) IF A FILM IS MORE THAN RENTAL_DURATION * 2 OVERDUE, CHARGE THE REPLACEMENT_COST
       --#   4) SUBTRACT ALL PAYMENTS MADE BEFORE THE DATE SPECIFIED
DECLARE
    v_rentfees DECIMAL(5,2); --#FEES PAID TO RENT THE VIDEOS INITIALLY
    v_overfees INTEGER;      --#LATE FEES FOR PRIOR RENTALS
    v_payments DECIMAL(5,2); --#SUM OF PAYMENTS MADE PREVIOUSLY
BEGIN
    SELECT COALESCE(SUM(film.rental_rate),0) INTO v_rentfees
    FROM film, inventory, rental
    WHERE film.film_id = inventory.film_id
      AND inventory.inventory_id = rental.inventory_id
      AND rental.rental_date <= p_effective_date
      AND rental.customer_id = p_customer_id;

    SELECT COALESCE(SUM(
        CASE
            -- If returned or overdue as of effective date
            WHEN (COALESCE(rental.return_date, p_effective_date) - rental.rental_date)
                 > (film.rental_duration * INTERVAL '1 day')
            THEN
                -- Total overdue days
                CASE 
                    WHEN EXTRACT(EPOCH FROM (
                            (COALESCE(rental.return_date, p_effective_date) - rental.rental_date)
                            - (film.rental_duration * INTERVAL '1 day')
                         )) / 86400
                         >
                         film.rental_duration * 2
                    THEN 
                        -- #3: replacement cost
                        film.replacement_cost
                    ELSE
                        -- #2: $1 per each overdue day
                        FLOOR(
                            EXTRACT(EPOCH FROM (
                              (COALESCE(rental.return_date, p_effective_date) - rental.rental_date)
                              - (film.rental_duration * INTERVAL '1 day')
                            )) / 86400
                        )
                END
            ELSE
                0
        END
    ),0) 
    INTO v_overfees
    FROM rental, inventory, film
    WHERE film.film_id = inventory.film_id
      AND inventory.inventory_id = rental.inventory_id
      AND rental.rental_date <= p_effective_date
      AND rental.customer_id = p_customer_id;

    SELECT COALESCE(SUM(payment.amount),0) INTO v_payments
    FROM payment
    WHERE payment.payment_date <= p_effective_date
    AND payment.customer_id = p_customer_id;

    RETURN v_rentfees + v_overfees - v_payments;
END;
$function$
;
SELECT public.get_customer_balance(15, '2017-02-15 08:57:20.000 +0200');

5.How do ‘group_concat’ and ‘_group_concat’ functions work? (database creation script might help) Where are they used?

_group_concat concatenates two text values with a comma separator.
group_concat repeatedly applies _group_concat to build a comma-separated list.
They exist only as demonstration code — an example of how to build custom aggregates.
PostgreSQL's native string_agg() makes them unnecessary.

6.What does ‘last_updated’ function do? Where is it used?
This trigger function automatically updates the last_update column whenever a row is modified.

The last_updated() function is a small helper function that PostgreSQL automatically calls whenever a row is updated in certain tables.

Each time a row is updated, last_updated() sets last_update = NOW() automatically.

You don’t need to write this manually in every UPDATE query — PostgreSQL.
The function is attached to multiple tables through BEFORE UPDATE triggers, for example:film, actor, customer, staff, store, address, category, city, country, inventory

Each table has a trigger like this:

CREATE TRIGGER last_updated
BEFORE UPDATE ON film
FOR EACH ROW
EXECUTE PROCEDURE last_updated();

Without this trigger function, developers would have to manually update the last_update column in every single UPDATE query.
This would be error-prone and easy to forget.

7.What is tmpSQL variable for in ‘rewards_report’ function? Can this function be recreated without EXECUTE statement and dynamic SQL? Why?

tmpSQL is a TEXT variable used to construct a SQL query as a text string (dynamic SQL), which is then executed through EXECUTE tmpSQL. Dynamic SQL is necessary only when table names are generated dynamically or when the structure of the SELECT statement must change depending on certain conditions. In the case of the rewards_report function, dynamic SQL is not required, because it does not involve dynamic table names, dynamic columns, or dynamic schemas. The only changing parameter is the date used in the condition WHERE payment_date BETWEEN p_start AND p_end, and this can be handled entirely with a static SQL query.
